package rand

import (
	"bytes"
	"crypto/tls"
	"encoding/hex"
	"fmt"
	"math/rand"
	"net/http"
	"strings"
	"time"

	"github.com/gobuffalo/packr"
	"github.com/makeos/mosdef/util"
	"github.com/pkg/errors"

	"github.com/BurntSushi/toml"
	"github.com/dedis/drand/beacon"
	"github.com/thoas/go-funk"
	"go.dedis.ch/kyber/v3/sign/bls"

	"github.com/imroc/req"

	"github.com/dedis/drand/core"
	"github.com/dedis/drand/key"
)

// DRander represents a component for getting random numbers
// from drand
type DRander interface {
	Init() error
	Get(index int) *DrandRandData
	Verify(rand, prev []byte, round uint64) error
}

func init() {
	rand.Seed(time.Now().UnixNano())
}

// HexByte properly handles JSON byte marshalling
type HexByte []byte

// UnmarshalJSON unmarshal the value to its original format
func (m *HexByte) UnmarshalJSON(data []byte) error {
	if len(data) < 2 || data[0] != '"' || data[len(data)-1] != '"' {
		return fmt.Errorf("Invalid hex string: %s", data)
	}
	bz2, err := hex.DecodeString(string(data[1 : len(data)-1]))
	if err != nil {
		return err
	}
	*m = bz2
	return nil
}

func (m HexByte) String() string {
	return strings.ToUpper(hex.EncodeToString(m))
}

// DRandRandomness holds randon value generated by drand
type DRandRandomness struct {
	Gid   int32
	Point HexByte
}

// DrandRandData represents the response from a drand server
type DrandRandData struct {
	Round      uint64
	Randomness *DRandRandomness
	Previous   HexByte
}

// DRand provides randomness generation using
// randomness beacon provided by drand and NIST.
type DRand struct {
	g           *key.Group
	gFile       string
	drandClient *core.Client
	interrupt   *util.Interrupt
}

// NewDRand creates an instance of Rand.
// The argument groupFile is the drand group file.
func NewDRand(interrupt *util.Interrupt) *DRand {
	return &DRand{
		g:           &key.Group{},
		drandClient: core.NewRESTClient(),
		interrupt:   interrupt,
	}
}

// Init initializes components required to generate a random value
func (r *DRand) Init() error {
	bx := packr.NewBox("./")
	groupData, err := bx.Find("group.toml")
	if err != nil {
		return err
	}

	return r.init(groupData)
}

func (r *DRand) init(groupData []byte) error {

	tomlVal := r.g.TOMLValue()
	if _, err := toml.DecodeReader(bytes.NewBuffer(groupData), tomlVal); err != nil {
		return errors.Wrap(err, "failed to decode group data")
	}

	if err := r.g.FromTOML(tomlVal); err != nil {
		return errors.Wrap(err, "failed to decode from toml struct")
	}

	return nil
}

// Get returns a 512-bits randomness
func (r *DRand) Get(index int) *DrandRandData {

	// Get a copy of the nodes in the drand group.
	// Shuffle the nodes list so we can access it randomly.
	var nodes = make([]*key.Identity, len(r.g.Nodes))
	copy(nodes[:], r.g.Nodes[:])
	nodes = funk.Shuffle(nodes).([]*key.Identity)

	// Configure the request object
	request := req.New()
	request.SetTimeout(10 * time.Second)
	transport, _ := request.Client().Transport.(*http.Transport)
	transport.TLSClientConfig = &tls.Config{
		MinVersion: tls.VersionTLS12,
		MaxVersion: tls.VersionTLS12,
	}

	var result *DrandRandData

	// Continuously request for randomness from
	// all nodes till one returns a valid value
	for len(nodes) > 0 {

		if r.interrupt.IsClosed() {
			return nil
		}

		node := nodes[0]
		resp, err := request.Get(fmt.Sprintf("https://%s/api/public/%d", node.Addr, index))
		if err != nil {
			nodes = nodes[1:]
			continue
		}

		res := DrandRandData{}
		err = resp.ToJSON(&res)
		if err != nil {
			nodes = nodes[1:]
			continue
		}

		// We need to verify the generated random value
		if err = r.Verify(res.Randomness.Point,
			res.Previous, res.Round); err != nil {
			nodes = nodes[1:]
			continue
		}

		result = &res
		break
	}

	if result == nil {
		return nil
	}

	return &DrandRandData{
		Randomness: &DRandRandomness{
			Point: result.Randomness.Point,
			Gid:   int32(result.Randomness.Gid),
		},
		Previous: result.Previous,
		Round:    result.Round,
	}
}

// Verify a drand generated random value
func (r *DRand) Verify(rand, prev []byte, round uint64) error {
	msg := beacon.Message(prev, round)
	return bls.Verify(key.Pairing, r.g.PublicKey.Key(), msg, rand)
}
